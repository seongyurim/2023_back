// 추상메소드를 1개라도 포함하면 해당 클래스는 객체화될 수 없다.
// 즉 객체화하지 못하고 상속으로만 의미가 있는 클래스가 되는 것이며
// 이를 '추상클래스'라고 한다.
public abstract class Unit {

    protected int attackSpped;
    
    // 원래 메소드: 실행의 용도
    // 현재 메소드: 약속(규약)의 용도일 뿐이지, 실행 목적으로 존재하는 것이 아니다.
    // 실행될 것이 아니기 때문에 실행부가 존재할 필요가 없다.
    // 따라서 약속용 메소드는 내용이 없다.
    // 하지만 내용이 아예 없으면 이게 규약 용도인지 무슨 용도인지 바로 알기 쉽지 않으므로
    // abstract라고 표시해둔다.(이것이 추상 메소드, abstrack method)
    public abstract void attack();


    // 물론 다른 메소드도 넣을 수 있다.
    public void move(int x, int y) {
        System.out.println("move : " + x + ", " + y);
    }

    // 추상클래스와 추상메소드의 단점
    // 1) 강한 강제성이 있지는 않다.
    // 2) 규약(attack)과 구현부(move)가 섞여 있으므로 순수한 규약이라고는 볼 수 없다.
    //    - 지금은 코드가 짧아서 괜찮지만, 코드가 길어지면 규약과 구현부가 여기저기 섞여 있어 리더빌리티 저하
    // 따라서 실무에서는 추상 개념을 자주 사용하지는 않는다.
    // 그래도 개념은 익혀두자. 클래스와 메소드가 오직 실행의 용도로만 존재하지는 않는다는 것을 알아두자.


    // 추상클래스 뒤에 나오는 봉인된 클래스(Sealed Class, 352p)는 배우지 않아도 된다.
    // Java 15부터 도입된 데다가, 앞으로 사용할 일이 전혀 없을 것이다.
    // 일반 프로그래밍이 아니라 라이브러리를 만들 때나 사용된다.

}
